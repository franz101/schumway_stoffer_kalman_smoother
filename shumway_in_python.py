# -*- coding: utf-8 -*-
"""Schumway in Python.ipynb

Automatically generated by Colaboratory.

Original file is located at
- Model estimation using the Shumway and Stoffer approach.
- Time Series Trading class and trading signal generation.
"""

import numpy as np
import pandas as pd

def create_nan_array(dim):
  a = np.empty(dim)
  a[:] = np.NaN
  return a

df = pd.read_csv("drive/MyDrive/SHUMWAY/blood.csv",  usecols=[1,2,3]) 
y = df.fillna(0)
num = y.shape[0]
A = np.zeros((3,3,num))
for i in range(num):
  if (y.values[i,1] > 0):
    A[:,:,i] = np.eye(3,3)
mu0 = np.zeros((3,1))
#TODO SIGMA0
Sigma0 = np.array(
          [[0.1, 0.,  0. ],
          [0. , 0.1, 0. ],
          [0. , 0.,  1. ]])

Phi = np.eye(3)
cQ = np.array(
     [[0.1, 0.,  0. ],
      [0. , 0.1, 0. ],
      [0. , 0.,  1. ]])
cR = np.array(
     [[0.1, 0.,  0. ],
      [0. , 0.1, 0. ],
      [0. , 0.,  1. ]])

def kalman_filter1(num,y,A,mu0,Sigma0,Phi,Ups,Gam,cQ,cR,input_num):
   # y is num by q  (time=row series=col)
   # A is a q by p matrix
   # R is q by q
   # mu0 is p by 1
   # Sigma0, Phi, Q are p by p
  Q = cQ @ cQ.T
  R = cR @ cR.T
  # Passed Test
  pdim = Phi.shape[0]
  qdim = y.shape[1]
  if type(input_num) != type(np.array):
    input_num = np.array([[input_num]])
  rdim = input_num.shape[1]
  if (np.max(abs(Ups))==0):
    Ups = np.zeros((pdim,rdim))
  if (np.max(abs(Gam))==0):
    Gam = np.zeros((qdim,rdim))
  xp = create_nan_array((pdim,1,num))
  Pp = create_nan_array((pdim,pdim,num))
  xf = create_nan_array((pdim,1,num))
  Pf = create_nan_array((pdim,pdim,num))
  innov = create_nan_array((qdim,1,num))
  sig = create_nan_array((qdim,qdim,num))
  ut = np.full((num,rdim), input_num)
  y_arr = y.values
  # initialize 
  x00 = np.array(mu0)
  P00 = np.array(Sigma0)
  for i in range(0,num):
    if i == 0:
      xp[:,:,0] =  Phi@x00 + np.expand_dims(Ups@ut[0,:],1)
      print("Phi")
      print(Phi)
      print("P00")
      print(P00)
      print("Q")
      print(Q)
      print(Phi@ P00 @ Phi.T +Q)
      Pp[:,:,0] =  Phi@ P00 @ Phi.T +Q

    else:
      xp[:,:,i] =  Phi@xf[:,:,i-1] + np.expand_dims(Ups@ut[i,:],1)
      Pp[:,:,i] =  (Phi@ Pf[:,:,i-1] )@ Phi.T +Q
    B = A[:,:,i]
    sigtemp= B @ Pp[:,:,i]@B.T+R 
    sig[:,:,i] = (sigtemp.T +sigtemp)/2
    siginv = np.linalg.inv(sig[:,:,i])
    K = (Pp[:,:,i]@B.T)@ siginv
    innov[:,:,i] =  np.expand_dims(np.diag((y_arr[i,:]-B@xp[:,:,i]-Gam@ut[i,:])),1)
    xf[:,:,i]= (xp[:,:,i] +K@innov[:,:,i] ) 
    Pf[:,:,i]= Pp[:,:,i] - (K@B)@Pp[:,:,i]
    sigmat = np.array(sig[:,:,i])# qdm #qdim
    if i == 0:
      like = np.log(np.linalg.det(sigmat))+ (innov[:,:,0].T@siginv)@innov[:,:,0]
    else:
      like = like + np.log(np.linalg.det(sigmat))+ (innov[:,:,i].T@siginv)@innov[:,:,i]
  like = 0.5*like

  return {"xp":xp,"Pp":Pp,"xf":xf,"Pf":Pf,"like":like,"innov":innov,
          "sig":sig,"K":K}


def k_smoother(num,y,A,mu0,Sigma0,Phi,Ups,Gam,cQ,cR,input):
  kf = kalman_filter1(num,y,A,mu0,Sigma0,Phi,Ups,Gam,cQ,cR,input)
  pdim = Phi.shape[0]
  xs = create_nan_array((pdim,1,num))
  Ps = create_nan_array((pdim,pdim,num))
  J = create_nan_array((pdim,pdim,num))
  xs[:,:,num-1] = kf["xf"][:,:,num-1]
  Ps[:,:,num-1] = kf["Pf"][:,:,num-1]
  for i in reversed(range(1,num)):
    J[:,:,i-1] = kf["Pf"][:,:,i-1]@Phi.T@np.linalg.solve(kf["Pp"][:,:,i],np.eye(kf["Pp"][:,:,i].shape[0]))
    xs[:,:,i-1] = kf["xf"][:,:,i-1]+J[:,:,i-1]@(xs[:,:,i]-kf["xp"][:,:,i])
    Ps[:,:,i-1] = kf["Pf"][:,:,i-1]+J[:,:,i-1]@(Ps[:,:,i]-kf["Pp"][:,:,i])@J[:,:,i-1].T
  x00=mu0
  P00=Sigma0
  J0=P00@Phi.T@np.linalg.solve(kf["Pp"][:,:,0],np.eye(kf["Pp"][:,:,0].shape[0]))
  #Todo cleanup
  x0n=(np.expand_dims(x00,1)+(J0@(xs[:,:,0]-kf["xp"][:,:,0])))[0,:,:]
  P0n=P00+J0@(Ps[:,:,0]-kf["Pp"][:,:,0])@J0.T
  return {"xs":xs,"Ps":Ps,"x0n":x0n,"P0n":P0n,"J0":J0,"J":J,"xp":kf["xp"],
          "Pp":kf["Pp"],"xf":kf["xf"],"Pf":kf["Pf"],"like":kf["like"],"Kn":kf["K"]
}

def em1(num,y,A,mu0,Sigma0,Phi,cQ,cR,max_iter=100,tol=0.001):
  pdim = Phi.shape[0]
  qdim = y.shape[1]
  cvg=1+tol
  like = np.zeros((max_iter,1))
  miss = np.where( np.abs(y)>0,0,1)
  print("iteration-loglikelihood \n")
  #----------------- start EM -------------------------
  for i in range(max_iter):
   
    ks = k_smoother(num,y,A,mu0,Sigma0,Phi,0,0,cQ,cR,0)
    like[i]=ks['like']
    print("   ",i, "        ", ks['like'], "\n")
    
    if(i>0):
      print("like")
      print(like)
      cvg=(like[i-1]-like[i])/abs(like[i-1])
      print("cvg",cvg,"iter",i)
      print(num,"num\n")
      print(mu0,"mu0\n")
      print(Sigma0,"Sigma0\n")
      print(Phi,"Phi")
      print(cR,"cR")
      print(cQ,"cQ")
      print(ks)
    if(cvg<0):
      print("Likelihood Not Increasing")
      break
    if(abs(cvg)<tol):
      break
    Pcs = create_nan_array((pdim,pdim,num))
    eye = np.eye(pdim)
    B = A[:,:,i]
    Pcs[:,:,num-1]=(eye-ks['Kn']@B)@Phi@ks['Pf'][:,:,num-2]
    k_range = reversed(range(2,num))
    for k in k_range:
      Pcs[:,:,k-1]=ks["Pf"][:,:,k-1]@(ks["J"][:,:,k-2]).T + \
           ks["J"][:,:,k-1]@(Pcs[:,:,k]-Phi@ks["Pf"][:,:,k-1])@(ks["J"][:,:,k-2]).T
    Pcs[:,:,0]=ks["Pf"][:,:,0]@(ks["J0"]).T + \
          ks["J"][:,:,0]@(Pcs[:,:,1]-Phi@ks["Pf"][:,:,0])@(ks["J0"]).T
    S11 = (ks["xs"][:,:,0]@(ks["xs"][:,:,0]).T) + ks["Ps"][:,:,0]
    S10 = ks["xs"][:,:,0]@(ks["x0n"]).T + Pcs[:,:,0]
    S00 = ks["x0n"]@(ks["x0n"]).T + ks["P0n"]
    B = A[:,:,0] 
    u = y.values[0:1,:].T-(B@ks["xs"][:,:,0])
    old_r = np.diag(miss[0,:])@(cR.T@cR)
    R = (u@u.T) + B@ks["Ps"][:,:,0]@B.T+old_r
    

    for j in range(1,num):
      S11 = S11 + (ks["xs"][:,:,j]@(ks["xs"][:,:,j]).T) + ks["Ps"][:,:,j]
      S10 = S10 + ks["xs"][:,:,j]@(ks["xs"][:,:,j-1]).T + Pcs[:,:,j]
      S00 = S00 + ks["xs"][:,:,j-1]@(ks["xs"][:,:,j-1]).T + ks["Ps"][:,:,j-1]
      B = A[:,:,j] 
      u = y.values[j:j+1,:].T-(B@ks["xs"][:,:,j])
      old_r = np.diag(miss[j,:])@(cR.T@cR)
      R = R + (u@u.T) + ((B@ks["Ps"][:,:,j])@B.T)+old_r
    Phi = S10@np.linalg.solve(S00,np.eye(S00.shape[0])) # passed
    Q = (S11-Phi@S10.T)/num #passed
    print("Qfuck")
    print(Q)
    Q = (Q+Q.T)/2
    cQ =  np.linalg.cholesky(Q,).T
    R = R/(num)
    R = np.diag(np.diag(R))
    cR = np.sqrt(R)
    mu0 = ks['x0n']
    Sigma0 = ks['P0n']
  return {"Phi":Phi,"Q":Q,"R":R,"mu0":mu0,"Sigma0":Sigma0,"like":like[:i],
          "niter":i,"cvg":cvg}
#k_smoother(num,y,A,mu0,Sigma0,Phi,0,0,cQ,cR,0)
em1(num, y, A, mu0, Sigma0, Phi, cQ, cR, 100, .001)
